<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lj | cloudmusic android team dev-blog]]></title>
  <link href="http://cloudmusic.github.io/blog/categories/lj/atom.xml" rel="self"/>
  <link href="http://cloudmusic.github.io/"/>
  <updated>2014-10-10T14:43:10+08:00</updated>
  <id>http://cloudmusic.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    <email><![CDATA[androidfb@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[android子view的pressed状态受父view的clickable影响分析]]></title>
    <link href="http://cloudmusic.github.io/blog/2014/10/10/android-view-pressed/"/>
    <updated>2014-10-10T14:36:17+08:00</updated>
    <id>http://cloudmusic.github.io/blog/2014/10/10/android-view-pressed</id>
    <content type="html"><![CDATA[<p>android从sdk16开始，修改了onTouchEvent的ACTION_DOWN代码(<a href="http://stackoverflow.com/questions/14179431/android-child-view-sharing-pressed-state-from-its-parent-view-in-jelly-bean">Android: Child elements sharing pressed state with their parent even when duplicateParentState specified</a>)，如下：</p>

<p>sdk16以前：
&#8220;`java
    case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;</p>

<pre><code>            if (performButtonActionOnTouchDown(event)) {
                break;
            }

            // Walk up the hierarchy to determine if we're inside a scrolling container.
            boolean isInScrollingContainer = isInScrollingContainer();

            // For views inside a scrolling container, delay the pressed feedback for
            // a short period in case this is a scroll.
            if (isInScrollingContainer) {
                mPrivateFlags |= PREPRESSED;
                if (mPendingCheckForTap == null) {
                    mPendingCheckForTap = new CheckForTap();
                }
                postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
            } else {
                // Not inside a scrolling container, so show the feedback right away
                mPrivateFlags |= PRESSED; //comment by bran
                refreshDrawableState();
                checkForLongClick(0);
            }
            break;
</code></pre>

<pre><code>sdk16及以后：
</code></pre>

<pre><code>case MotionEvent.ACTION_DOWN:
            mHasPerformedLongPress = false;

            if (performButtonActionOnTouchDown(event)) {
                break;
            }

            // Walk up the hierarchy to determine if we're inside a scrolling container.
            boolean isInScrollingContainer = isInScrollingContainer();

            // For views inside a scrolling container, delay the pressed feedback for
            // a short period in case this is a scroll.
            if (isInScrollingContainer) {
                mPrivateFlags |= PFLAG_PREPRESSED;
                if (mPendingCheckForTap == null) {
                    mPendingCheckForTap = new CheckForTap();
                }
                postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
            } else {
                // Not inside a scrolling container, so show the feedback right away
                setPressed(true);
                checkForLongClick(0);
            }
            break;
</code></pre>

<pre><code>
后者会调用setPressed方法，代码如下：
</code></pre>

<pre><code>public void setPressed(boolean pressed) {
    final boolean needsRefresh = pressed != ((mPrivateFlags &amp; PFLAG_PRESSED) == PFLAG_PRESSED);

    if (pressed) {
        mPrivateFlags |= PFLAG_PRESSED;
    } else {
        mPrivateFlags &amp;= ~PFLAG_PRESSED;
    }

    if (needsRefresh) {
        refreshDrawableState();
    }
    dispatchSetPressed(pressed);
}

//viewgroup的实现
protected void dispatchSetPressed(boolean pressed) {
    final View[] children = mChildren;
    final int count = mChildrenCount;
    for (int i = 0; i &lt; count; i++) {
        final View child = children[i];
        // Children that are clickable on their own should not
        // show a pressed state when their parent view does.
        // Clearing a pressed state always propagates.
        if (!pressed || (!child.isClickable() &amp;&amp; !child.isLongClickable())) {
            child.setPressed(pressed);
        }
    }
}
</code></pre>

<p>&#8220;`</p>

<p>可以看出sdk16以后如果子view是!isClickable，父view是isClickable（父view如果是!isClickable都不会处理ACTION_DOWN事件），则即使在子view区域外的点击也会触发子view的pressed行为。这样改的原因不得而知，但个人觉得这不是正常期望的，UI表现上来看，父view点击任何区域子view都会触发pressed。</p>

<p>这种情景是存在的，比如子view是不可点，但又要设置父view可点以防点击父view会触发父父view事件。如果要处理这种情况，父view可以覆盖dispatchSetPressed方法进行重写，或者直接父view设置setEnable(false)。</p>
]]></content>
  </entry>
  
</feed>
